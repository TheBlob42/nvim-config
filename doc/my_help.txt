=============================================================================
COPY MATCHING LINES                                             *my-copy-lines*

First "clear" your target register (here register `a`) using |q|:
>
	qaq
<
Then you can copy all matching lines via |:g| (here using register `a`):
>
	:g/<pattern>/y A
<
=============================================================================
REMOVE DUPLICATES                                        *my-remove-duplicates*

You can remove dupliate lines from a buffer using:
>
	:sort u
<
=============================================================================
DIFF                                                                  *my-diff*

Open all buffers you want to compare in separate |windows| (same |tabpage|)
and execute the following command:
>
	:windo diffthis
<
Stop the diff view with:
>
	:windo diffoff
<
To "export" the diff you can use the builtin `2html` plugin by executing:
>
	:TOhtml
<
Note: This will save the diff in a `Diff.html` file in the current working
directory. Open it in a browser to get a nice overview.

=============================================================================
CLOJURE                                                            *my-clojure*

Using Neovim as Clojure editor.

-----------------------------------------------------------------------------
REPL                                                          *my-clojure-repl*

When opening a Clojure file the `conjure` plugin automatically connects to an
existing REPL. If none is found it tries to use `babashka` (if installed). To
open an interactive REPL for the usage with Neovim use the following:
>
    {:deps
     {org.clojure/clojure {:mvn/version "1.10.1"}
      nrepl/nrepl {:mvn/version "0.7.0"}
      cider/cider-nrepl {:mvn/version "0.25.2"}}}
<
To make this work check for the following dependencies in your `deps.edn`
file:
>
    clj -m nrepl.cmdline \
	--middleware "[cider.nrepl/cider-middleware]" \
	--interactive
<
=============================================================================
POSTMAN                                                    *my-curl* *my-postman*

Using Neovim as a simple alternative to Postman.

Inspired by the following blog post:
https://mahmoudashraf.dev/blog/no-more-postman-just-curl-and-vim/

Create a `filename.sh` file and write out your request with `curl`:
>
	curl -s -X POST \
	    -u '<username>:<password>' \
	    '<url>' \
	    -H 'Content-Type: application/json' \
	    -d '{ "key": "value" }'
<
Note: We're using the `.sh` extension only to get syntax highlighting

Now you can execute it via |:!|, `sh` and |:%|:
>
	:!sh %
<
=============================================================================
GRADLE                                                              *my-gradle*

Everything about Gradle.

-----------------------------------------------------------------------------
DEBUGGING                                                 *my-gradle-debugging*

Sometimes it is needed to debug a specific Gradle task either because the
dependencies are not handled correctly otherwise or because there is no
"MainClass" class which could be used instead.

First start the Gradle task with the `--debug-jvm` flag:
>
	./gradlew bootRun --debug-jvm
<
Once that is running and waiting for a debugger to attach we can do so via
|dap.txt| by calling |dap.run()|:
>
        require('dap').run {
            type = 'java',
            request = 'attach',
            name = 'gradle attach',
            hostName = '127.0.0.1',
            port = 5005,
        }
<
There is a dedicated keybinding for this task:
>
	<localleader>dG
<
-----------------------------------------------------------------------------
MISC                                                         *my-gradle-misc*

Pass command line arguments~

Use `--args` to pass command line arguments to a Gradle task
>
	./gradlew customTask --args="Some argument"
<
=============================================================================
JAVA                                                         *my-jdtls* *my-java*

Everything about Java and JDTLS.

-----------------------------------------------------------------------------
VERSIONS                                   *my-jdtls-versions* *my-java-versions*

Make sure that the Java version to start the JDTLS (probably your system
default) matches the version it was compiled with. If you additionally use the
`java-debug` and `java-test` test extensions also make sure that these have
been compiled with the same JDK as the server. Otherwise you might see weird
errors and debugging will not work correctly.

JDTLS			required JDK version~

till `0.58.0`		8
till `1.12.0`		11
from `1.13.0`		17

JAVA-DEBUG-ADAPTER	required JDK version~

till `0.34.0`		8
till `0.37.0`		11
from `0.38.0`		17

JAVA-TEST		required JDK version~

till `0.35.0`		11
from `0.35.1`		17

Note: You can install specific versions of any tool with `mason.nvim` by using
`:MasonInstall jdtls@v1.12.0` (pass the version directly to the install
command).

-----------------------------------------------------------------------------
CLASSPATH                                *my-jdtls-classpath* *my-java-classpath*

Make sure that all source sets and folders of your project are correctly
referenced in the `.classpath` file. Should you encounter a situation in which
a class can not be found during autocompletion or a resource file (e.g.
`log4j2.xml`) is not taken into consideration when running a unit test or
something similar, take a peek and check if everything is set up correctly.

You can easily add the missing `<classpathentry>` yourself to fix these kind
of issues. Take the already existing entries for some inspiration:
>
	<classpathentry kind="src"
			output="bin/test"
			path="src/test/resources">
		<attributes>
			<attribute name="gradle_scope" value="test"/>
			<attribute name="gradle_used_by_scope" value="test"/>
			<attribute name="test" value="true"/>
		</attributes>
	</classpathentry>
<
-----------------------------------------------------------------------------
COMPILER OPTIONS                           *my-jdtls-compiler* *my-java-compiler*

Due to the vast variety of options there are many which can not be set
directly in the JDTLS configuration. In case of the Java compiler options
there is a setting (`java.settings.url`) to link a properties file with your
specific options:
>
	{
		[...]
		settings = {
			java = {
				settings = {
					url = 'path to your properties file'
				}
			}
		}
	}
<
For the list of all available options see:
https://github.com/eclipse/eclipse.jdt.ls/wiki/Language-Server-Settings-&-Capabilities#java-compiler-options

=============================================================================
TOMCAT DEBUG                                                  *my-tomcat-debug*

To debug a Tomcat server via DAP first set the following required environment
variables:
>
	export JPDA_ADDRESS=8000
	export JPDA_TRANSPORT=dt_socket
	export JPDA_SUSPEND=y
<
Then start the Tomcat server via `jdpa`:
>
	./bin/catalina.sh jdpa run
<
The process will now wait on the specific port (here `8000`) till the debugger
is attached before actually starting the Tomcat server. To attach our DAP
handler afterwards we need to run:
>
	require('dap'). {
		type = 'java',
		request = 'attach',
		name = 'tomcat attach',
		hostName = '127.0.0.1',
		port = 8000, -- depends on the value of JPDA_ADDRESS
	}
<
=============================================================================
PACKER SNAPSHOT                                            *my-packer-snapshot*

If |PackerSnapshotRollback| does not work check if the snapshot file contains
any entries for a plugin which is actually loaded from a local directory (e.g.
for development). This fails the rollback with a very incomprehensible error
message.

=============================================================================
MACROS HELP                                                         *my-macros*

Everything about Neovim macros.

-----------------------------------------------------------------------------
WRAPSCAN                                                   *my-macros-wrapscan*

Disable 'wrapscan' so that the macro fails at the end of the file (if using
a search).
>
	set nowrapscan
<
-----------------------------------------------------------------------------
SUB MACROS                                                *my-macros-submacros*

For example to call a recursive sub macro.
>
	:exe "normal! @a"
<
In order to catch the errors of the sub macro (instead of aborting it) we can
use |:try| and |execute|.
>
	:try | exe "normal! @a" | endtry
<
-----------------------------------------------------------------------------
SPEEEEEEED                                                    *my-macros-speed*

Neovim can be become quite "slow" when executing big macros with lot of
actions or a lot of repetition. Lets take a simple macro just inserting "Hello
World" and a new line:
>
	qq i"Hello World"<CR><ESC> q
<
If we execute this macro quite often we experience a significant delay (unless
you're loading Neovim without plugins `nvim -u NONE`):
>
	:normal 1000@q
<
To mitigate these performance issues it most often makes sense to use
|:noautocmd| for the execution:
>
	:noautocmd normal 1000@q
<
It could also make sense to set |'paste'| before executing the macro.
https://www.reddit.com/r/neovim/comments/tsol2n/why_macros_are_so_slow_compared_to_emacs/

=============================================================================
vim:tw=78:ts=8:noet:ft=help:norl:
